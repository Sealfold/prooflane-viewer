<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Prooflane Viewer (M0)</title>
  <style>
    :root {
      --bg: #0b0f14;
      --fg: #e6edf3;
      --muted: #9aa7b2;
      --card: #121820;
      --accent: #2f81f7;
      --ok: #2ea043;
      --warn: #d29922;
      --err: #f85149;
      --border: #263241;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0; padding: 0; background: var(--bg); color: var(--fg);
      font-family: ui-sans-serif, system-ui, Segoe UI, Roboto, Helvetica, Arial, Apple Color Emoji, Segoe UI Emoji;
      line-height: 1.45;
    }
    header { padding: 16px 20px; border-bottom: 1px solid var(--border); display: flex; align-items: center; gap: 12px; }
    h1 { margin: 0; font-size: 18px; font-weight: 600; }
    main { display: grid; grid-template-columns: 360px 1fr; gap: 16px; padding: 16px; }
    @media (max-width: 960px) { main { grid-template-columns: 1fr; } }
    .panel { background: var(--card); border: 1px solid var(--border); border-radius: 8px; padding: 16px; }
    .controls { display: grid; gap: 10px; }
    .help { color: var(--muted); font-size: 13px; }
    .badge { display: inline-flex; align-items: center; gap: 8px; padding: 6px 10px; border-radius: 999px; font-weight: 600; font-size: 12px; }
    .badge.ok { background: rgba(46,160,67,0.16); color: var(--ok); border: 1px solid rgba(46,160,67,0.48); }
    .badge.warn { background: rgba(210,153,34,0.16); color: var(--warn); border: 1px solid rgba(210,153,34,0.48); }
    .badge.err { background: rgba(248,81,73,0.16); color: var(--err); border: 1px solid rgba(248,81,73,0.48); }
    .kv { margin: 8px 0 0; font-size: 13px; color: var(--muted); }
    .kv span { color: var(--fg); }
    .list { margin: 12px 0 0; padding-left: 18px; font-size: 13px; color: var(--muted); }
    iframe { width: 100%; min-height: 70vh; border: none; border-radius: 0; background: transparent; }
    .filename { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size: 12px; color: var(--muted); }
    .grid { display: grid; gap: 8px; }
    .grid.cols-2 { grid-template-columns: 1fr 1fr; }
    .card { background: #0f151d; border: 1px solid var(--border); border-radius: 8px; padding: 12px; }
    .label { color: var(--muted); font-size: 12px; }
    .value { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; }
    .actions { display: flex; gap: 8px; flex-wrap: wrap; }
    .code { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; background: #0c131b; border: 1px dashed var(--border); border-radius: 6px; padding: 8px; color: var(--muted); }
    .small { font-size: 12px; color: var(--muted); }
    .mb-6 { margin-bottom: 6px; }
    .mb-8 { margin-bottom: 8px; }
    .mt-8 { margin-top: 8px; }
    .mt-12 { margin-top: 12px; }
    .section-title { font-size: 13px; font-weight: 700; color: var(--fg); margin: 4px 0 6px; }
    .pill { display: inline-block; border: 1px solid var(--border); border-radius: 999px; padding: 2px 8px; font-size: 12px; color: var(--muted); margin-right: 6px; }
    .pill.ok { color: var(--ok); border-color: rgba(46,160,67,0.5); }
    .pill.warn { color: var(--warn); border-color: rgba(210,153,34,0.5); }
    .pill.err { color: var(--err); border-color: rgba(248,81,73,0.5); }
    .tabs { display: flex; gap: 8px; margin-bottom: 8px; }
    .tab { border: 1px solid var(--border); background: #0f1720; color: var(--fg); padding: 6px 10px; border-radius: 6px; cursor: pointer; font-size: 12px; }
    .tab[disabled] { opacity: 0.5; cursor: not-allowed; }
    .hidden { display: none; }
    details summary { cursor: pointer; }
    .toolbar { display: flex; gap: 8px; margin-bottom: 8px; }
    .toc-panel { display: none; background: #0f151d; border: 1px solid var(--border); border-radius: 8px; padding: 8px; margin-bottom: 8px; max-height: 220px; overflow: auto; }
    .toc-link { display: block; color: var(--accent); text-decoration: none; font-size: 12px; padding: 2px 0; }
    .toc-indent-1 { margin-left: 0; }
    .toc-indent-2 { margin-left: 12px; }
    .toc-indent-3 { margin-left: 24px; }
    .callout { background: #0f151d; border: 1px solid var(--border); border-radius: 8px; padding: 10px; font-size: 12px; color: var(--muted); }
    .callout strong { color: var(--fg); }
    button, label[role="button"] {
      border: 1px solid var(--border); background: #0f1720; color: var(--fg); padding: 8px 10px; border-radius: 6px; cursor: pointer;
    }
    button:hover, label[role="button"]:hover { border-color: #33465d; }
    input[type="file"] { display: none; }
    .status { display: flex; align-items: center; gap: 8px; }
    .status:focus-visible { outline: 2px solid var(--accent); outline-offset: 2px; }
    .ml-auto { margin-left: auto; }
    .user-label { margin-left: 8px; opacity: .8; }
    .hidden-inline { display: none; }
    .endpoint { border: 1px solid var(--border); background: #0f1720; color: var(--fg); border-radius: 6px; padding: 4px 6px; font-size: 12px; }
    .error { color: var(--err); font-size: 13px; white-space: pre-wrap; }
    .oktext { color: var(--ok); font-size: 13px; }
  </style>
  <meta name="description" content="Prooflane Viewer renders canonical HTML and basic verification status for .pla packages (M0)." />
  <meta name="color-scheme" content="dark light" />
  <link rel="icon" href="data:," />
  <script src="https://cdn.jsdelivr.net/npm/mammoth@1.8.0/mammoth.browser.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.min.js"></script>
  <script>try{pdfjsLib.GlobalWorkerOptions.workerSrc='https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.worker.min.js';}catch(e){}</script>
  <script type="module">
    import { parsePla, renderPdf } from '../../packages/pde-web/dist/pde-web.js';
    window.PDE = { parsePla, renderPdf };
  </script>
  <script>
    // Minimal in-browser PLA viewer (M0):
    // - Accept a folder selection (webkitdirectory)
    // - Validate presence of required files from manifest.json
    // - Render canonical/index.html in iframe (srcdoc)
    // - Show badge: Verified / Tampered / Unverifiable

    let fileIndex = new Map();
    let currentProfiles = [];
    let currentDefaultProfile = null;

    function resetState() {
      fileIndex.clear();
      currentProfiles = [];
      currentDefaultProfile = null;
      document.getElementById('manifestName').textContent = '';
      setBadge('warn', 'Unverifiable');
      document.getElementById('details').innerHTML = '';
      document.getElementById('viewer').srcdoc = '<!doctype html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"></head><body style="font-family:system-ui,sans-serif;color:#111;padding:1rem">Select a PLA file or Upload a file to render canonical HTML.</body></html>';
      document.getElementById('err').textContent = '';
    }

    async function detectProfiles() {
      const names = new Set();
      for (const key of fileIndex.keys()) {
        const m = key.match(/^search\/profiles\/([^/]+)\/metadata\.json$/i);
        if (m) names.add(m[1]);
      }
      currentProfiles = Array.from(names).sort();
      currentDefaultProfile = currentProfiles[0] || null;
      // Attempt to read default flag from metadata
      for (const name of currentProfiles) {
        const metaFile = fileIndex.get(`search/profiles/${name}/metadata.json`);
        if (!metaFile) continue;
        try {
          const js = JSON.parse(await readAsText(metaFile));
          if (js && (js.default === true || js.is_default === true)) { currentDefaultProfile = name; break; }
        } catch {}
      }
    }

    function updateRagUi() {
      const ragBtn = document.getElementById('btnRagPack');
      const help = document.getElementById('ragHelp');
      const sel = document.getElementById('profileSelect');
      const hasEmbedded = currentProfiles.length > 0;
      if (hasEmbedded) {
        ragBtn.textContent = currentDefaultProfile ? `Export RAG Pack (${currentDefaultProfile})` : 'Export RAG Pack';
        ragBtn.disabled = false;
        if (help) help.innerHTML = '<strong>RAG Pack</strong> â€” Export the embedded vector profile for direct indexing (no re-embedding).';
        if (currentProfiles.length > 1 && sel) {
          sel.innerHTML = '';
          for (const name of currentProfiles) {
            const opt = document.createElement('option');
            opt.value = name; opt.textContent = name + (name === currentDefaultProfile ? ' (default)' : '');
            if (name === currentDefaultProfile) opt.selected = true;
            sel.appendChild(opt);
          }
          sel.classList.remove('hidden-inline');
        } else if (sel) {
          sel.classList.add('hidden-inline');
        }
      } else {
        ragBtn.textContent = 'Download RAG Pack';
        ragBtn.disabled = false;
        if (sel) sel.classList.add('hidden-inline');
      }
    }

    function setBadge(kind, text) {
      const el = document.getElementById('badge');
      el.className = 'badge ' + kind;
      el.textContent = text;
    }

    function readAsText(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onerror = () => reject(reader.error);
        reader.onload = () => resolve(String(reader.result));
        reader.readAsText(file);
      });
    }

    function readAsArrayBuffer(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onerror = () => reject(reader.error);
        reader.onload = () => resolve(reader.result);
        reader.readAsArrayBuffer(file);
      });
    }

    async function ensureSavePla(filesMap, baseName) {
      // Build .pla (zip) blob
      const zip = new JSZip();
      for (const [path, file] of filesMap.entries()) {
        const buf = await file.arrayBuffer();
        zip.file(path, buf);
      }
      const blob = await zip.generateAsync({ type: 'blob', mimeType: 'application/zip' });
      // Auto-download to browser's default download location
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = `${baseName}.pla`;
      document.body.appendChild(a); a.click(); a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 4000);
      return { saved: true, name: `${baseName}.pla` };
    }

    async function createPlaFromPdf(file) {
      try {
        // Minimal, client-side PLA structure in memory
        const now = new Date().toISOString();
        const baseName = (file.name || 'document.pdf').replace(/\.pdf$/i, '');
        const manifest = {
          format: 'PROOFLANE',
          spec_version: '0.1',
          title: baseName,
          created: now,
          doc_id: 'pla:local:' + baseName,
          latest_commit: 'pla:local:' + baseName + ':0001',
          commits: ['history/0001.json'],
          workflow: { state: 'workflow/state.json', log: 'workflow/log.jsonl' }
        };
        const commit = {
          parent: null,
          timestamp: now,
          author: { name: 'Local', email: 'local@example.com' },
          purpose: 'Import PDF',
          delta: { added: ['manifest.json', 'canonical/index.html'], changed: [], removed: [] },
          commit_id: 'pla:local:' + baseName + ':0001',
          signatures: [],
          anchors: []
        };
        const state = { version: '1.0', states: ['imported'], initial_state: 'imported', current_state: 'imported', transitions: [] };
        const log = [{ ts: now, actor: 'local@example.com', action: 'import' }];
        const canonicalHtml = `<!doctype html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>${baseName}</title><style>html,body{margin:0;padding:0;background:transparent} .page{box-shadow:none;margin:0 auto;background:transparent;display:block}</style></head><body><main><div id="pdfPages"></div></main></body></html>`;

        // Build in-memory files as a pseudo-folder for the viewer
        const files = new Map();
        function add(path, content) {
          files.set(path, new File([content], path, { type: 'application/json' }));
        }
        add('manifest.json', JSON.stringify(manifest, null, 2));
        add('history/0001.json', JSON.stringify(commit, null, 2));
        add('workflow/state.json', JSON.stringify(state, null, 2));
        files.set('workflow/log.jsonl', new File([log.map(l => JSON.stringify(l)).join('\n') + '\n'], 'workflow/log.jsonl', { type: 'text/plain' }));
        files.set('canonical/index.html', new File([canonicalHtml], 'canonical/index.html', { type: 'text/html' }));
        // Keep original PDF for preview
        const pdfBuf = await readAsArrayBuffer(file);
        files.set('source.pdf', new File([pdfBuf], 'source.pdf', { type: 'application/pdf' }));

        // Require user save before rendering
        const saveResult = await ensureSavePla(files, baseName);
        if (!saveResult.saved) {
          throw new Error('Save canceled');
        }
        // Replace the current fileIndex with our generated PLA and render
        fileIndex = files;
        document.getElementById('manifestName').textContent = `${saveResult.name}/manifest.json`;
        setBadge('ok', 'Verified');
        document.getElementById('err').textContent = '';
        const frame = document.getElementById('viewer');
        frame.onload = null;
        frame.srcdoc = canonicalHtml;
        frame.onload = () => {
          try {
            const pdfBlobUrl = URL.createObjectURL(pdfBlob);
            const win = frame.contentWindow;
            if (!win) return;
            const doc = win.document;
            const container = doc && doc.getElementById('pdfPages');
            if (!container || !window.PDE) return;
            // Use PDE web adapter
            window.PDE.renderPdf(container, pdfBlob, { scale: 1.2, skipFirstPage: false });
          } catch {}
        };
        // Populate meta immediately for created PLA
        const metaTitle = document.getElementById('metaTitle');
        const metaDocId = document.getElementById('metaDocId');
        const metaCreated = document.getElementById('metaCreated');
        const metaLatest = document.getElementById('metaLatest');
        const metaWorkflow = document.getElementById('metaWorkflow');
        const metaSecurity = document.getElementById('metaSecurity');
        const metaVector = document.getElementById('metaVector');
        const metaSuite = document.getElementById('metaSuite');
        if (metaTitle) metaTitle.textContent = manifest.title;
        if (metaDocId) metaDocId.textContent = manifest.doc_id;
        if (metaCreated) metaCreated.textContent = manifest.created;
        if (metaLatest) metaLatest.textContent = manifest.latest_commit;
        if (metaWorkflow) metaWorkflow.textContent = 'present';
        if (metaSecurity) metaSecurity.textContent = 'none';
        if (metaVector) metaVector.textContent = 'none';
        if (metaSuite) metaSuite.textContent = 'Word (Processing)';
        const pdfBlob = new Blob([pdfBuf], { type: 'application/pdf' });
        // Render PDF into the canonical view (inside iframe) for near-original fidelity
        try {
          const pdfBlobUrl = URL.createObjectURL(pdfBlob);
          setTimeout(async () => {
            const frame = document.getElementById('viewer');
            if (!frame) return;
            const frameDoc = frame.contentDocument || frame.contentWindow?.document;
            if (!frameDoc) return;
            const container = frameDoc.getElementById('pdfPages');
            if (!container || !window.pdfjsLib) return;
            const loadingTask = window.pdfjsLib.getDocument({ url: pdfBlobUrl });
            const pdf = await loadingTask.promise;
            const startPage = pdf.numPages > 1 ? 2 : 1;
            for (let i = startPage; i <= pdf.numPages; i++) {
              const page = await pdf.getPage(i);
              const viewport = page.getViewport({ scale: 1.2 });
              const canvas = frameDoc.createElement('canvas');
              canvas.width = viewport.width;
              canvas.height = viewport.height;
              canvas.className = 'page';
              container.appendChild(canvas);
              await page.render({ canvasContext: canvas.getContext('2d'), viewport }).promise;
            }
          }, 50);
        } catch {}
        const source = document.getElementById('sourceContainer');
        source.innerHTML = '';
        const iframe = document.createElement('iframe');
        iframe.title = 'PDF Preview';
        iframe.src = URL.createObjectURL(pdfBlob);
        iframe.style.width = '100%';
        iframe.style.minHeight = '70vh';
        iframe.style.border = '1px solid var(--border)';
        iframe.style.borderRadius = '8px';
        source.appendChild(iframe);
        document.getElementById('tabSource').disabled = false;
        document.getElementById('details').innerHTML = '';
      } catch (e) {
        setBadge('warn', 'Unverifiable');
        document.getElementById('err').textContent = 'Failed to create PLA from PDF: ' + e;
      }
    }

    async function createPlaFromDocx(file) {
      const arrayBuffer = await readAsArrayBuffer(file);
      const result = await window.mammoth.convertToHtml({ arrayBuffer });
      const html = `<!doctype html><html lang="en"><head><meta charset="utf-8"><title>${file.name}</title></head><body>${result.value}</body></html>`;
      // Reuse PDF flow with different canonical HTML and source rendering
      await createPlaFromGeneric(file, html, 'docx');
    }

    async function createPlaFromXlsx(file) {
      const buf = await readAsArrayBuffer(file);
      const wb = XLSX.read(buf, { type: 'array' });
      const wsName = wb.SheetNames[0];
      const ws = wb.Sheets[wsName];
      const htmlTable = XLSX.utils.sheet_to_html(ws);
      const html = `<!doctype html><html lang="en"><head><meta charset="utf-8"><title>${file.name}</title></head><body>${htmlTable}</body></html>`;
      await createPlaFromGeneric(file, html, 'xlsx');
    }

    async function createPlaFromGeneric(file, canonicalHtml, kind) {
      const now = new Date().toISOString();
      const baseName = (file.name || 'document').replace(/\.(pdf|docx|xlsx)$/i, '');
      const manifest = {
        format: 'PROOFLANE',
        spec_version: '0.1',
        title: baseName,
        created: now,
        doc_id: 'pla:local:' + baseName,
        latest_commit: 'pla:local:' + baseName + ':0001',
        commits: ['history/0001.json'],
        workflow: { state: 'workflow/state.json', log: 'workflow/log.jsonl' }
      };
      const commit = {
        parent: null,
        timestamp: now,
        author: { name: 'Local', email: 'local@example.com' },
        purpose: 'Import ' + kind.toUpperCase(),
        delta: { added: ['manifest.json', 'canonical/index.html'], changed: [], removed: [] },
        commit_id: 'pla:local:' + baseName + ':0001',
        signatures: [],
        anchors: []
      };
      const state = { version: '1.0', states: ['imported'], initial_state: 'imported', current_state: 'imported', transitions: [] };
      const log = [{ ts: now, actor: 'local@example.com', action: 'import' }];

      const files = new Map();
      function add(path, content) {
        files.set(path, new File([content], path, { type: 'application/json' }));
      }
      add('manifest.json', JSON.stringify(manifest, null, 2));
      add('history/0001.json', JSON.stringify(commit, null, 2));
      add('workflow/state.json', JSON.stringify(state, null, 2));
      files.set('workflow/log.jsonl', new File([log.map(l => JSON.stringify(l)).join('\n') + '\n'], 'workflow/log.jsonl', { type: 'text/plain' }));
      files.set('canonical/index.html', new File([canonicalHtml], 'canonical/index.html', { type: 'text/html' }));

      const srcBuf = await readAsArrayBuffer(file);
      files.set('source.' + kind, new File([srcBuf], 'source.' + kind, { type: file.type || 'application/octet-stream' }));

      const saveResult = await ensureSavePla(files, baseName);
      if (!saveResult.saved) { throw new Error('Save canceled'); }
      fileIndex = files;
      document.getElementById('manifestName').textContent = `${saveResult.name}/manifest.json`;
      setBadge('ok', 'Verified');
      document.getElementById('err').textContent = '';
      const frame2 = document.getElementById('viewer');
      frame2.onload = null;
      frame2.srcdoc = canonicalHtml;
      // Populate meta immediately for created PLA
      const metaTitle2 = document.getElementById('metaTitle');
      const metaDocId2 = document.getElementById('metaDocId');
      const metaCreated2 = document.getElementById('metaCreated');
      const metaLatest2 = document.getElementById('metaLatest');
      const metaWorkflow2 = document.getElementById('metaWorkflow');
      const metaSecurity2 = document.getElementById('metaSecurity');
      const metaVector2 = document.getElementById('metaVector');
      const metaSuite2 = document.getElementById('metaSuite');
      if (metaTitle2) metaTitle2.textContent = manifest.title;
      if (metaDocId2) metaDocId2.textContent = manifest.doc_id;
      if (metaCreated2) metaCreated2.textContent = manifest.created;
      if (metaLatest2) metaLatest2.textContent = manifest.latest_commit;
      if (metaWorkflow2) metaWorkflow2.textContent = 'present';
      if (metaSecurity2) metaSecurity2.textContent = 'none';
      if (metaVector2) metaVector2.textContent = 'none';
      if (metaSuite2) metaSuite2.textContent = kind === 'docx' ? 'Word (Processing)' : (kind === 'xlsx' ? 'Spreadsheet' : 'Word (Processing)');
      const source = document.getElementById('sourceContainer');
      source.innerHTML = '';
      if (/pdf$/i.test(kind)) {
        const iframe = document.createElement('iframe');
        iframe.title = 'PDF Preview';
        iframe.src = URL.createObjectURL(new Blob([srcBuf], { type: 'application/pdf' }));
        iframe.style.width = '100%';
        iframe.style.minHeight = '70vh';
        iframe.style.border = '1px solid var(--border)';
        iframe.style.borderRadius = '8px';
        source.appendChild(iframe);
      } else if (/docx$/i.test(kind)) {
        const div = document.createElement('div');
        div.innerHTML = canonicalHtml;
        source.appendChild(div);
      } else if (/xlsx$/i.test(kind)) {
        const div = document.createElement('div');
        div.innerHTML = canonicalHtml;
        source.appendChild(div);
      }
      document.getElementById('tabSource').disabled = false;
      document.getElementById('details').innerHTML = '';
    }

    async function onPickFolder(ev) {
      resetState();
      const files = Array.from(ev.target.files || []);
      if (!files.length) return;
      // Index files by relative path (lowercase, forward slashes)
      for (const f of files) {
        const key = (f.webkitRelativePath || f.name).replaceAll('\\\\', '/');
        fileIndex.set(key, f);
      }
      // Try to find manifest.json in root
      const manifestFile = files.find(f => /(^|\/)manifest\.json$/i.test(f.webkitRelativePath || f.name));
      if (!manifestFile) {
        setBadge('warn', 'Unverifiable');
        document.getElementById('err').textContent = 'manifest.json not found in selected folder.';
        return;
      }
      const manifestRel = manifestFile.webkitRelativePath || manifestFile.name;
      document.getElementById('manifestName').textContent = manifestRel;
      let manifest;
      try {
        const txt = await readAsText(manifestFile);
        manifest = JSON.parse(txt);
      } catch (e) {
        setBadge('warn', 'Unverifiable');
        document.getElementById('err').textContent = 'Failed to parse manifest.json: ' + e;
        return;
      }
      // Basic required fields
      const required = ['format','spec_version','title','created','doc_id','latest_commit','commits','workflow'];
      const missing = required.filter(k => !(k in manifest));
      const detail = [];
      if (missing.length) {
        setBadge('err', 'Tampered');
        detail.push('Missing fields: ' + missing.join(', '));
      }
      // File presence checks
      const rootPrefix = manifestRel.includes('/') ? manifestRel.slice(0, manifestRel.lastIndexOf('/') + 1) : '';
      function getFileByRel(rel) {
        const norm = rel.replaceAll('\\\\', '/').replace(/^\.\//,'');
        const candidates = [norm, './' + norm, rootPrefix + norm];
        for (const c of candidates) {
          if (fileIndex.has(c)) return fileIndex.get(c);
        }
        // Fallback: suffix match
        for (const [k, f] of fileIndex.entries()) {
          if (k === norm || k.endsWith('/' + norm)) return f;
        }
        return undefined;
      }
      function exists(rel) { return !!getFileByRel(rel); }
      if (manifest && manifest.workflow) {
        const ws = manifest.workflow.state;
        const wl = manifest.workflow.log;
        if (!exists(ws)) detail.push('Missing workflow.state: ' + ws);
        if (!exists(wl)) detail.push('Missing workflow.log: ' + wl);
      }
      // Commit chain checks (lightweight)
      let chainOk = true;
      const commits = Array.isArray(manifest.commits) ? manifest.commits : [];
      const commitJsons = [];
      for (const c of commits) {
        if (!exists(c)) {
          detail.push('Missing commit: ' + c);
          chainOk = false;
        }
      }
      for (const c of commits) {
        const f = getFileByRel(c);
        if (!f) continue;
        try {
          const txt = await readAsText(f);
          const js = JSON.parse(txt);
          commitJsons.push(js);
        } catch (e) {
          detail.push('Failed to read commit ' + c + ': ' + e);
          chainOk = false;
        }
      }
      for (let i = 0; i < commitJsons.length; i++) {
        const rec = commitJsons[i] || {};
        const parent = rec.parent;
        const commitId = rec.commit_id;
        // first commit parent must be null
        if (i === 0 && parent !== null) {
          detail.push('Commit[0] parent must be null');
          chainOk = false;
        }
        // subsequent commit parent must equal previous commit_id
        if (i > 0) {
          const prevId = (commitJsons[i-1] || {}).commit_id;
          if (parent !== prevId) {
            detail.push('Commit[' + i + '] parent mismatch: ' + parent + ' != ' + prevId);
            chainOk = false;
          }
        }
        // minimal type checks
        if (typeof commitId !== 'string' || !commitId) {
          detail.push('Commit[' + i + '] missing/invalid commit_id');
          chainOk = false;
        }
      }

      // Sign/Anchor checks when security present
      let signOk = true;
      if (manifest && manifest.security) {
        const last = commitJsons[commitJsons.length - 1] || {};
        const sigs = Array.isArray(last.signatures) ? last.signatures : [];
        if (sigs.length === 0) {
          detail.push('Latest commit must include at least one signature (Sign profile).');
          signOk = false;
        }
        const anchors = Array.isArray(last.anchors) ? last.anchors : [];
        for (let i = 0; i < anchors.length; i++) {
          const tok = (anchors[i] && anchors[i].token) || '';
          if (typeof tok === 'string' && !tok.startsWith('base64:')) {
            detail.push('Anchor token invalid prefix at anchors[' + (i+1) + ']');
            signOk = false;
          }
        }
      }
      // Canonical view
      const canonicalPath = 'canonical/index.html';
      if (!exists(canonicalPath)) {
        detail.push('Missing canonical: ' + canonicalPath);
      } else {
        const f = getFileByRel(canonicalPath);
        try {
          const html = await readAsText(f);
          document.getElementById('viewer').srcdoc = html;
        } catch (e) {
          detail.push('Failed to read canonical/index.html: ' + e);
        }
      }
      // Populate meta (ensure elements exist)
      const metaTitle = document.getElementById('metaTitle');
      const metaDocId = document.getElementById('metaDocId');
      const metaCreated = document.getElementById('metaCreated');
      const metaLatest = document.getElementById('metaLatest');
      const metaWorkflow = document.getElementById('metaWorkflow');
      const metaSecurity = document.getElementById('metaSecurity');
      const metaVector = document.getElementById('metaVector');
      if (metaTitle && metaDocId && metaCreated && metaLatest && metaWorkflow && metaSecurity) {
        metaTitle.textContent = manifest.title || '';
        metaDocId.textContent = manifest.doc_id || '';
        metaCreated.textContent = manifest.created || '';
        metaLatest.textContent = manifest.latest_commit || '';
        metaWorkflow.textContent = manifest.workflow ? 'present' : 'missing';
        const last = commitJsons[commitJsons.length - 1] || {};
        const sigs = Array.isArray(last.signatures) ? last.signatures.length : 0;
        const anchors = Array.isArray(last.anchors) ? last.anchors.length : 0;
        const securityPresent = manifest.security || sigs > 0 || anchors > 0;
        metaSecurity.textContent = securityPresent ? `present (sig ${sigs}, anchors ${anchors})` : 'none';
        if (metaVector) {
          // vector readiness: embeddings metadata and chunks consistency
          let vectorText = 'none';
          try {
            const metaFile = getFileByRel('search/metadata.json');
            const chunksFile = getFileByRel('search/chunks.jsonl');
            const embedFile = getFileByRel('search/embeddings.bin');
            if (metaFile && chunksFile && embedFile) {
              const metaJson = JSON.parse(await readAsText(metaFile));
              const dim = Number(metaJson.dim || 0);
              const chunksTxt = await readAsText(chunksFile);
              const lines = chunksTxt.split(/\r?\n/).filter(Boolean);
              const count = lines.length;
              const size = (await embedFile.arrayBuffer()).byteLength;
              const expected = count * dim * 4;
              if (dim > 0 && count > 0) {
                vectorText = size === expected ? `ready (dim ${dim}, chunks ${count})` : `mismatch (dim ${dim}, chunks ${count})`;
              } else {
                vectorText = 'present (metadata incomplete)';
              }
            }
          } catch {}
          metaVector.textContent = vectorText;
        }
      }

      // Decide status
      if (!missing.length && chainOk && signOk && !detail.some(d => d.startsWith('Missing') || d.startsWith('Failed'))) {
        setBadge('ok', 'Verified');
        document.getElementById('err').textContent = '';
      } else if (detail.length) {
        setBadge('err', 'Tampered');
        document.getElementById('err').textContent = '';
      }
      // Render details
      const ul = document.createElement('ul');
      ul.className = 'list';
      for (const d of detail) {
        const li = document.createElement('li');
        li.textContent = d;
        ul.appendChild(li);
      }
      const detailsBox = document.getElementById('details');
      if (detailsBox) {
        detailsBox.innerHTML = '';
        if (detail.length === 0) {
          const ok = document.createElement('div');
          ok.className = 'oktext';
          ok.textContent = 'No issues detected.';
          detailsBox.appendChild(ok);
        } else {
          detailsBox.appendChild(ul);
        }
      }
      // profiles
      detectProfiles();
      updateRagUi();
    }

    window.addEventListener('DOMContentLoaded', () => {
      resetState();
      // Default demo user label and simple mock auth toggle
      const userEl = document.getElementById('userLabel');
      if (userEl) userEl.textContent = 'User: Demo-Anonymous';
      const authBtn = document.getElementById('btnAuth');
      const endpointInput = document.getElementById('vecEndpoint');
      const autoUploadCk = document.getElementById('autoUpload');
      window.SEALFOLD_VECTOR_ENDPOINT = '';
      endpointInput.addEventListener('change', () => { window.SEALFOLD_VECTOR_ENDPOINT = endpointInput.value.trim(); });
      let signedIn = false;
      authBtn.addEventListener('click', () => {
        signedIn = !signedIn;
        if (signedIn) {
          userEl.textContent = 'User: demo.user@contoso.com (Contoso Ltd)';
          authBtn.textContent = 'Sign out';
        } else {
          userEl.textContent = 'User: Demo-Anonymous';
          authBtn.textContent = 'Sign in';
        }
      });
      document.getElementById('pickDoc').addEventListener('change', async (ev) => {
        const file = (ev.target.files || [])[0];
        if (!file) return;
        const name = (file.name || '').toLowerCase();
        if (name.endsWith('.pdf') || file.type === 'application/pdf') { await createPlaFromPdf(file); showSource(); return; }
        if (name.endsWith('.docx')) { await createPlaFromDocx(file); showSource(); return; }
        if (name.endsWith('.xlsx')) { await createPlaFromXlsx(file); showSource(); return; }
        alert('Unsupported file type. Please upload PDF, DOCX, or XLSX.');
      });
      // Tabs switching
      const tabCanonical = document.getElementById('tabCanonical');
      const tabSource = document.getElementById('tabSource');
      const frameCanon = document.getElementById('viewer');
      const sourceContainer = document.getElementById('sourceContainer');
      function showCanonical() {
        frameCanon.classList.remove('hidden');
        sourceContainer.classList.add('hidden');
        document.getElementById('docToolbar').classList.remove('hidden-inline');
        setRagHelpVisible(true);
      }
      function showSource() {
        if (tabSource.disabled) return;
        frameCanon.classList.add('hidden');
        sourceContainer.classList.remove('hidden');
        document.getElementById('docToolbar').classList.add('hidden-inline');
        setRagHelpVisible(false);
      }
      tabCanonical.addEventListener('click', showCanonical);
      tabSource.addEventListener('click', showSource);

      // Load from .pla zip
      document.getElementById('pickPlaZip').addEventListener('change', async (ev) => {
        const file = (ev.target.files || [])[0];
        if (!file) return;
        resetState();
        try {
          const buf = await readAsArrayBuffer(file);
          const zip = await JSZip.loadAsync(buf);
          fileIndex.clear();
          const entries = Object.keys(zip.files);
          for (const name of entries) {
            const entry = zip.files[name];
            if (entry.dir) continue;
            const blob = await entry.async('blob');
            fileIndex.set(name.replaceAll('\\\\','/'), new File([blob], name, { type: blob.type || 'application/octet-stream' }));
          }
          // Reuse folder flow by faking a FileList selection of manifest.json
          const manifestNames = entries.filter(n => /(^|\/)manifest\.json$/i.test(n));
          if (!manifestNames.length) throw new Error('manifest.json not found in .pla');
          // Trigger minimal checks
          const fakeEvent = { target: { files: Array.from(fileIndex.values()) } };
          await onPickFolder(fakeEvent);
        } catch (e) {
          setBadge('warn', 'Unverifiable');
          document.getElementById('err').textContent = 'Failed to read .pla: ' + e;
        }
      });

      // Toolbar actions
      document.getElementById('btnPrint').addEventListener('click', () => {
        const frame = document.getElementById('viewer');
        if (frame && frame.contentWindow) {
          // Ensure we only print the iframe content
          frame.contentWindow.focus();
          frame.contentWindow.print();
        }
      });
      document.getElementById('btnRagPack').addEventListener('click', async () => {
        try {
          if (!window.JSZip && !window.JSZIP && !window.JSZipUtils) {
            // JSZip already loaded globally as JSZip
          }
          const files = Array.from(fileIndex.entries());
          const sel = document.getElementById('profileSelect');
          const selected = (sel && !sel.classList.contains('hidden-inline') && sel.value) ? sel.value : (currentDefaultProfile || currentProfiles[0]);
          const profilePrefix = currentProfiles.length ? `search/profiles/${selected}/` : 'search/';
          const matching = files.filter(([name]) => name.startsWith(profilePrefix));
          if (matching.length === 0) {
            alert('No vector profile found yet. This demo will enable RAG Pack download once profiles are added.');
            return;
          }
          const zip = new JSZip();
          for (const [name, file] of matching) {
            const buf = await file.arrayBuffer();
            zip.file(name.replace(/^search\//,''), buf);
          }
          const blob = await zip.generateAsync({ type: 'blob' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url; a.download = 'rag-pack.zip';
          document.body.appendChild(a); a.click(); a.remove();
          setTimeout(() => URL.revokeObjectURL(url), 3000);
          // Optional auto indexing to connected vector DB if configured
          if (autoUploadCk && autoUploadCk.checked && window.SEALFOLD_VECTOR_ENDPOINT) {
            try {
              await fetch(window.SEALFOLD_VECTOR_ENDPOINT, { method: 'POST', headers: { 'Content-Type': 'application/zip' }, body: blob });
            } catch {}
          }
        } catch (e) {
          alert('Failed to create RAG Pack: ' + e);
        }
      });
      document.getElementById('btnToc').addEventListener('click', () => {
        const frame = document.getElementById('viewer');
        const panel = document.getElementById('tocPanel');
        if (!frame || !frame.contentDocument) return;
        const doc = frame.contentDocument;
        const headings = Array.from(doc.querySelectorAll('h1,h2,h3'));
        if (!headings.length) { panel.style.display = 'none'; return; }
        panel.innerHTML = '';
        headings.forEach((h, idx) => {
          const level = h.tagName === 'H1' ? 1 : h.tagName === 'H2' ? 2 : 3;
          const id = h.id || `toc-${idx}`;
          h.id = id;
          const a = document.createElement('a');
          a.href = `#${id}`;
          a.textContent = h.textContent || `Section ${idx+1}`;
          a.className = `toc-link toc-indent-${level}`;
          a.addEventListener('click', (e) => {
            e.preventDefault();
            frame.contentWindow.location.hash = id;
          });
          panel.appendChild(a);
        });
        panel.style.display = panel.style.display === 'none' || !panel.style.display ? 'block' : 'none';
      });
      // Show RAG help when toolbar is visible (Prooflane Document)
      function setRagHelpVisible(isVisible) {
        const help = document.getElementById('ragHelp');
        if (!help) return;
        if (isVisible) help.classList.remove('hidden-inline'); else help.classList.add('hidden-inline');
      }
    });
  </script>
  <!-- Security: This viewer does not fetch remote resources and only renders local canonical HTML via srcdoc. -->
</head>
<body>
  <header>
    <h1>Prooflane Viewer</h1>
    <div class="status ml-auto" role="status" aria-live="polite" tabindex="0">
      <span id="badge" class="badge warn">Unverifiable</span>
    </div>
    <div class="small user-label" id="userLabel">User: Demo-Anonymous</div>
    <button id="btnAuth" type="button" class="user-label">Sign in</button>
    <input id="vecEndpoint" class="endpoint user-label" placeholder="Vector endpoint (optional)" />
    <label class="small user-label"><input type="checkbox" id="autoUpload" /> auto-upload RAG Pack</label>
  </header>
  <main>
    <section class="panel">
      <div class="controls">
        <div class="section-title">Interact</div>
        <div class="grid">
          <div class="card">
            <div class="small mb-6">Upload a document (PDF, DOCX, XLSX)</div>
            <div class="small mb-8">We will generate a minimal PLA in your browser and render it.</div>
            <div class="small mb-8">A .pla file will auto-download to your default downloads folder before rendering.</div>
            <div class="actions">
              <label role="button">
                <input id="pickDoc" type="file" accept="application/pdf,application/vnd.openxmlformats-officedocument.wordprocessingml.document,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet,.pdf,.docx,.xlsx" />
                âž• Create PLA from document
              </label>
            </div>
          </div>
          <div class="card">
            <div class="small mb-6">Select an existing PLA (.pla)</div>
            <div class="small mb-8">Loads the package, renders its canonical HTML, and shows provenance/governance metadata.</div>
            <div class="actions">
              <label role="button">
                <input id="pickPlaZip" type="file" accept="application/zip,.pla" />
                ðŸ“¦ Select .pla file
              </label>
            </div>
            <div class="kv">Manifest: <span id="manifestName" class="filename"></span></div>
            <div id="err" class="error" aria-live="polite"></div>
          </div>
          <div class="callout">
            <strong>Access & Sharing</strong><br/>
            Viewing this document requires authentication. Sharing requires a configured enterprise workflow. Organizations (same or external) federate via Microsoft Entra ID or other common identity providers.
          </div>
        </div>
        <!-- CLI section hidden for now -->
        <div class="section-title mt-12">Details</div>
        <div class="card">
          <div class="label">Details</div>
          <div id="details"></div>
        </div>
        <div class="card">
          <div class="label">Meta</div>
          <div class="small mb-8">Prooflane embeds document governance, provenance, and vector metadata to enable strong semantic reasoning and verification.</div>
          <div id="meta" class="grid">
            <div><span class="pill">Title</span> <span id="metaTitle" class="value"></span></div>
            <div><span class="pill">Doc ID</span> <span id="metaDocId" class="value"></span></div>
            <div><span class="pill">Created</span> <span id="metaCreated" class="value"></span></div>
            <div><span class="pill">Latest</span> <span id="metaLatest" class="value"></span></div>
            <div><span class="pill">Workflow</span> <span id="metaWorkflow" class="value"></span></div>
            <div><span class="pill">Security</span> <span id="metaSecurity" class="value"></span></div>
            <div><span class="pill">Vector</span> <span id="metaVector" class="value"></span></div>
            <div><span class="pill">Suite</span> <span id="metaSuite" class="value">Word (Processing)</span></div>
          </div>
        </div>
      </div>
    </section>
    <section class="panel">
      <div class="tabs">
        <button id="tabSource" class="tab" disabled>Original</button>
        <button id="tabCanonical" class="tab" title="Canonical Prooflane document view (normalized HTML per spec)">Prooflane Document</button>
      </div>
      <div id="docToolbar" class="toolbar hidden-inline">
        <button id="btnPrint" type="button">Print</button>
        <button id="btnToc" type="button">Table of Contents</button>
        <select id="profileSelect" class="hidden-inline"></select>
        <button id="btnRagPack" type="button" title="Download vector profile contents as a zip (stub)">Download RAG Pack</button>
      </div>
      <div id="ragHelp" class="callout hidden-inline">
        <strong>RAG Pack</strong> â€” A ready-to-index vector profile extracted from this Prooflane document.
        It includes chunks, embeddings, metadata, and a map so vector databases can ingest without re-embedding.
        Use it when you want search/Q&A over this file or need to share vectors across environments without exposing your embedding keys.
        By default, Prooflane is self-contained and can embed profiles inside the `.pla`. Some organizations prefer storing large profiles on company servers for governance and cost. This demo downloads a RAG Pack on demand; you can disable download and keep profiles server-side in production.
      </div>
      <div id="tocPanel" class="toc-panel"></div>
      <div id="sourceContainer" class="hidden"></div>
      <iframe id="viewer" title="Prooflane Document" sandbox="allow-scripts allow-same-origin"></iframe>
    </section>
  </main>
</body>
</html>